<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Pong — Single File</title>
		<style>
			:root{--bg:#0b1020;--fg:#e6eef8;--accent:#56ccf2}
			html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
			.wrap{height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px}
			canvas{background:linear-gradient(180deg,#07101a, #0b2030);border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,.6);cursor:crosshair}
			.hud{display:flex;gap:12px;align-items:center}
			.score{font-size:20px;font-weight:700;color:var(--accent)}
			button{background:transparent;border:1px solid rgba(255,255,255,.08);padding:8px 12px;border-radius:6px;color:var(--fg);cursor:pointer}
			.help{font-size:12px;color:rgba(230,238,248,.7)}
			footer{font-size:12px;color:rgba(230,238,248,.5);margin-top:8px}
		</style>
	</head>
	<body>
		<div class="wrap">
			<div class="hud">
				<div class="score" id="score">Player 0 — 0 Computer</div>
				<button id="startBtn">Start</button>
				<button id="resetBtn">Reset</button>
				<div class="help">Move your mouse over the game to control the left paddle. Click canvas to pause/resume.</div>
			</div>

			<canvas id="game" width="960" height="600"></canvas>
			<footer>Single-file Pong clone — mouse controls left paddle. Built for local play.</footer>
		</div>

		<script>
			// Basic Pong clone. Left paddle follows mouse Y. Right paddle is simple AI.
			const canvas = document.getElementById('game');
			const ctx = canvas.getContext('2d');
			const DPR = Math.max(1, window.devicePixelRatio || 1);
			// Resize canvas to CSS pixels * DPR for crispness
			function resize(){
				const cssW = Math.min(window.innerWidth - 40, 1000);
				const cssH = Math.min(window.innerHeight - 160, 700);
				canvas.style.width = cssW + 'px';
				canvas.style.height = cssH + 'px';
				canvas.width = Math.floor(cssW * DPR);
				canvas.height = Math.floor(cssH * DPR);
				ctx.setTransform(DPR,0,0,DPR,0,0);
			}
			window.addEventListener('resize', resize);
			resize();

			// Game state
			const state = {
				running: false,
				paused: false,
				scoreLeft: 0,
				scoreRight: 0,
			};

			const P = {
				paddles: {
					w: 12,
					h: 110,
				},
				ball: {
					r: 8,
				},
				maxScore: 11,
			};

			const field = {
				w: () => canvas.width / DPR,
				h: () => canvas.height / DPR,
			};

			// Entities
			const left = { x: 20, y: field.h() / 2 - P.paddles.h/2, vy:0 };
			const right = { x: ()=> field.w() - 20 - P.paddles.w, y: field.h() / 2 - P.paddles.h/2, vy:0 };
			const ball = { x: field.w()/2, y: field.h()/2, vx: 0, vy: 0, r: P.ball.r };

			// Mouse control
			let mouseY = field.h()/2;
			canvas.addEventListener('mousemove', e => {
				const rect = canvas.getBoundingClientRect();
				const y = (e.clientY - rect.top);
				mouseY = Math.max(0, Math.min(rect.height, y));
				// Convert to game coords (taking DPR and CSS size into account)
				const cssToGame = canvas.height / DPR / rect.height; // scale factor
				const gameY = mouseY * (canvas.height / DPR) / rect.height;
				left.y = gameY - P.paddles.h/2;
			});

			// Touch support (single finger)
			canvas.addEventListener('touchmove', e => {
				e.preventDefault();
				const touch = e.touches[0];
				const rect = canvas.getBoundingClientRect();
				const y = (touch.clientY - rect.top);
				const gameY = y * (canvas.height / DPR) / rect.height;
				left.y = Math.max(0, Math.min(field.h() - P.paddles.h, gameY - P.paddles.h/2));
			}, {passive:false});

			// Pause/resume on click
			canvas.addEventListener('click', () => {
				state.paused = !state.paused;
			});

			// Start/reset buttons
			document.getElementById('startBtn').addEventListener('click', () => {
				if (!state.running) startGame();
				state.paused = false;
			});
			document.getElementById('resetBtn').addEventListener('click', () => {
				state.scoreLeft = 0; state.scoreRight = 0; updateScore(); resetRound(); state.paused = true; state.running = false;
			});

			function startGame(){
				state.running = true;
				state.paused = false;
				state.scoreLeft = 0;
				state.scoreRight = 0;
				updateScore();
				resetRound();
				lastTime = performance.now();
				requestAnimationFrame(loop);
			}

			function resetRound(servingToLeft = false){
				const w = field.w(), h = field.h();
				ball.x = w/2; ball.y = h/2; ball.r = P.ball.r;
				const speed = 300; // px/sec
				const angle = (Math.random() * Math.PI/3) - Math.PI/6; // -30deg..30deg
				const dir = servingToLeft ? -1 : 1;
				ball.vx = dir * speed * Math.cos(angle);
				ball.vy = speed * Math.sin(angle);
				// Center paddles
				left.y = h/2 - P.paddles.h/2;
				right.y = h/2 - P.paddles.h/2;
			}

			function updateScore(){
				document.getElementById('score').textContent = `Player ${state.scoreLeft} — ${state.scoreRight} Computer`;
			}

			// Simple AI for right paddle
			function aiUpdate(dt){
				const target = ball.y - P.paddles.h/2;
				const speed = 280; // px/sec
				if (right.y + P.paddles.h/2 < target - 6) right.y += speed * dt;
				else if (right.y + P.paddles.h/2 > target + 6) right.y -= speed * dt;
				right.y = Math.max(0, Math.min(field.h() - P.paddles.h, right.y));
			}

			// Collision helpers
			function rectsCollide(rx, ry, rw, rh, cx, cy, cr){
				// Find closest point to circle
				const closestX = Math.max(rx, Math.min(cx, rx + rw));
				const closestY = Math.max(ry, Math.min(cy, ry + rh));
				const dx = cx - closestX;
				const dy = cy - closestY;
				return (dx*dx + dy*dy) <= cr*cr;
			}

			// Draw
			function draw(){
				const w = field.w(), h = field.h();
				// Clear
				ctx.clearRect(0,0,w,h);
				// Midline
				ctx.fillStyle = 'rgba(255,255,255,0.06)';
				const dashH = 14; const gap = 12; let y = 10;
				while(y < h - 10){ ctx.fillRect(w/2 - 1, y, 2, dashH); y += dashH + gap; }

				// Paddles
				ctx.fillStyle = '#cfeffd';
				ctx.fillRect(left.x, left.y, P.paddles.w, P.paddles.h);
				ctx.fillRect(right.x(), right.y, P.paddles.w, P.paddles.h);

				// Ball
				ctx.beginPath(); ctx.fillStyle = '#f6f9ff'; ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();

				// HUD small
				ctx.fillStyle = 'rgba(230,238,248,0.06)'; ctx.fillRect(8,8,120,32);
			}

			let lastTime = performance.now();
			function loop(now){
				if (!state.running) return;
				const dt = Math.max(0, (now - lastTime) / 1000);
				lastTime = now;
				if (!state.paused){
					// Update AI
					aiUpdate(dt);

					// Update ball
					ball.x += ball.vx * dt;
					ball.y += ball.vy * dt;

					// Top/bottom collisions
					if (ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }
					if (ball.y + ball.r > field.h()){ ball.y = field.h() - ball.r; ball.vy *= -1; }

					// Paddle collisions
					if (rectsCollide(left.x, left.y, P.paddles.w, P.paddles.h, ball.x, ball.y, ball.r) && ball.vx < 0){
						ball.x = left.x + P.paddles.w + ball.r; // push out
						ball.vx = Math.abs(ball.vx) * 1.05; // speed up
						// add spin depending on where it hit
						const rel = (ball.y - (left.y + P.paddles.h/2)) / (P.paddles.h/2);
						ball.vy += rel * 200;
					}
					if (rectsCollide(right.x(), right.y, P.paddles.w, P.paddles.h, ball.x, ball.y, ball.r) && ball.vx > 0){
						ball.x = right.x() - ball.r; // push out
						ball.vx = -Math.abs(ball.vx) * 1.05;
						const rel = (ball.y - (right.y + P.paddles.h/2)) / (P.paddles.h/2);
						ball.vy += rel * 200;
					}

					// Score
					if (ball.x < -50){ state.scoreRight += 1; updateScore(); if (state.scoreRight >= P.maxScore) gameOver('Computer'); else resetRound(true); }
					if (ball.x > field.w() + 50){ state.scoreLeft += 1; updateScore(); if (state.scoreLeft >= P.maxScore) gameOver('Player'); else resetRound(false); }
				}

				// clamp paddles
				left.y = Math.max(0, Math.min(field.h() - P.paddles.h, left.y));
				right.y = Math.max(0, Math.min(field.h() - P.paddles.h, right.y));

				draw();
				requestAnimationFrame(loop);
			}

			function gameOver(winner){
				state.paused = true;
				state.running = false;
				// show simple alert
				setTimeout(()=>{
					if (confirm(winner + ' wins! Play again?')){
						startGame();
					}
				}, 40);
			}

			// Initialize
			updateScore();
			// Provide a small autoplay start so page doesn't start running without user action
			// Allow pressing space to toggle pause
			window.addEventListener('keydown', e => {
				if (e.code === 'Space') { state.paused = !state.paused; }
				if (e.code === 'Enter' && !state.running) startGame();
			});

			// First paint
			draw();
		</script>
	</body>
</html>